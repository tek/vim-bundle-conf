clearsnippets test

global !p
import tek_vim_py_test
import tek_vim_py_inspect
from amino import *
from amino.util.string import *
endglobal

snippet cl "class"
class $1:
	${0:pass}
endsnippet

snippet s "self" w
self.
endsnippet

snippet ss "self private" w
self._
endsnippet

snippet def "function" !
def ${1}(`!p
if snip.indent:
	snip.rv = 'self'
	snip.rv += (", " if len(t[2]) else "")`${2}) -> ${3:None}:
	${0}
endsnippet

snippet deff "explicit free function" !
def ${1}(${2}) -> ${3:None}:
	${0}
endsnippet

snippet defp "property" !
@property
def ${1}(self) -> ${3}:
	${0}
endsnippet

snippet defz "lazy property" !b
@lazy
def ${1}(self) -> ${3}:
	${0}
endsnippet

snippet defl "private function" !
def _${1}(`!p
if snip.indent:
	snip.rv = 'self'
	snip.rv += (", " if len(t[2]) else "")`${2}) -> ${3}:
	${0}
endsnippet

snippet defL "private property" !
@property
def _${1}(self) -> ${3}:
	${0}
endsnippet

snippet defc "classmethod" !
@classmethod
def ${1}(`!p
snip.rv = 'self'
snip.rv += (", " if len(t[2]) else "")`${2}) -> ${3}:
	${0}
endsnippet

snippet defst "staticmethod" !
@staticmethod
def ${1}(${2}) -> ${3}:
	${0}
endsnippet

snippet decf "decorated function" !b
@$1
def $2(`!p
if snip.indent:
	snip.rv = 'self'
	snip.rv += (", " if len(t[3]) else "")`$3) -> ${3}:
	${0}
endsnippet

snippet defa "abstract method" !
@abc.abstractmethod
def ${1}(self, $2) -> $3:
	...
endsnippet

snippet defap "abstract property" !
@abc.abstractproperty
def ${1}(self) -> $2:
	...
endsnippet

snippet inf "logger.info" !b
logger.info(${0})
endsnippet

snippet defs "special function" !
def __${1}__(self`!p
snip.rv = (', ' if len(t[2]) else '')`${2}) -> ${3}:
	${0:pass}
endsnippet

snippet init "init function" !b
def __init__(self`!p
snip.rv = (', ' if len(t[1]) else '')`${1}) -> None:
`!p
def go(h, t):
  snip.shift()
  first = snip.mkline(h)
  snip.shift()
  rest = t / snip.mkline
  snip.rv = '\n'.join(rest.cons(first))
def pss():
  snip.rv = 'pass'
List.wrap(t[1].split(', ')).map(lambda a: f'self.{a} = {a}')\
  .detach_head.map2(go) | pss
`$0
endsnippet

snippet ds "docstring" !
''' ${0:doc}
'''
endsnippet

snippet i "import" !b
import $0
endsnippet

snippet try "Try / Except" !b
try:
	${VISUAL}
except ${1:Exception}`!p
snip.rv = (' as ' if len(t[2]) else '')`${2:e}:
	${3}
endsnippet

snippet try "Try / Except / Else" b
try:
	${1:pass}
except ${2:Exception}`!p
snip.rv = (' as ' if len(t[3]) else '')`${3:e}:
	${4:raise $3}
else:
	${5:pass}
endsnippet

snippet try "Try / Except / Finally" b
try:
	${1:pass}
except ${2:Exception}`!p
snip.rv = (' as ' if len(t[3]) else '')`${3:e}:
	${4:raise $3}
finally:
	${5:pass}
endsnippet

snippet try "Try / Except / Else / Finally" b
try:
	${1:pass}
except${2: ${3:Exception}`!p
snip.rv = (' as ' if len(t[3]) else '')`${4:e}}:
	${5:raise}
else:
	${6:pass}
finally:
	${7:pass}
endsnippet

snippet "([\([]([^\([.]+)(\.\S+)?\sf)f" "generator for with call on iterator" !r
`!p
snip.rv = '{}or {}'.format(match.group(1), match.group(2))` in ${2:`!p snip.rv = match.group(2)`s}
endsnippet

snippet "\S\sf" "generator for" !r
`!p
snip.rv = '{}or'.format(match.group(0))` ${1:iterator} in ${2:iterable}
endsnippet

snippet sup "super" !i
super().${1:`!p
snip.rv = tek_vim_py_test.current_function_name()`}(${2:`!p
f = tek_vim_py_inspect.containing_function()
if f:
	args = f.args
	a = List.wrap(args.args[1:] + args.kwonlyargs) / _.arg
	s = List(Maybe(args.vararg) / _.arg / '*{}'.format,
					 Maybe(args.kwarg) / _.arg / '**{}'.format).join
	snip.rv = ', '.join(a + s)
`})
endsnippet

snippet aa "private attribute assignment" !b
self._${1:argname} = $1
endsnippet

snippet wv "with statement from visual" !b
with ${VISUAL} as ${2}:
endsnippet

snippet r "return statement" !b
return ${0:value}
endsnippet

global !p
import random
import string

def randname():
    return ''.join(random.sample(string.ascii_lowercase, 6))
endglobal

snippet p "print" !b
print(${1:'${2:text}'})
endsnippet

snippet pr "print repr" !b
print(repr(${0}))
endsnippet

snippet with "context" !b
with ${1:manager}${3: as ${2:identifier}}:
	${0}
endsnippet

snippet from "from import" !b
from $1 import $2
endsnippet

snippet f "from import" !b
from $1 import $2
endsnippet

snippet ti "mypy ignore" !
 # type: ignore
endsnippet

snippet l "self.log" !b
self.log.$1
endsnippet

snippet d "self.log.verbose" !w
self.log.verbose($1)
endsnippet

snippet mes "ribosome message" !b
$1 = message('$1'$2)
endsnippet

snippet jmes "ribosome json message" !b
$1 = json_message('$1'$2)
endsnippet

snippet defh "handle" !b
@handle($1)
def `!p snip.rv = snake_case(t[1])`(self):
    $0
endsnippet

snippet defH "may handle" !b
@may_handle($1)
def `!p snip.rv = snake_case(t[1])`(self):
    $0
endsnippet

snippet nl "ribosome logging import" !b
from ribosome.logging import log
log.verbose($1)
endsnippet

snippet mc "message command" !b
@msg_command($1)
def $2(self):
    pass
endsnippet

snippet at "init attribute" b
self.$1 = $1
endsnippet

snippet "self.(\w+) = (\w+)" "init attribute continuation" r
`!p snip.rv = match.group(0)`
self.$1 = $1
endsnippet

snippet ex "klk expectation" b
def $1(self) -> Expectation:
    return k(1).must(equal(1))
endsnippet
