clearsnippets test

global !p
import tek_vim_py_test
import tek_vim_py_inspect
from amino import *
endglobal

snippet cl "class"
class ${1:MyClass}(${2:object}):
	${0:pass}
endsnippet

snippet s "self" w
self.
endsnippet

snippet ss "self private" w
self._
endsnippet

snippet def "function" !
def ${1}(`!p
if snip.indent:
	snip.rv = 'self'
	snip.rv += (", " if len(t[2]) else "")`${2}):
	${0}
endsnippet

snippet deff "explicit free function" !
def ${1}(${2}):
	${0}
endsnippet

snippet defp "property" !
@property
def ${1}(self):
	${0}
endsnippet

snippet defz "lazy property" !b
@lazy
def ${1}(self):
	${0}
endsnippet

snippet defl "private function" !
def _${1}(`!p
if snip.indent:
	snip.rv = 'self'
	snip.rv += (", " if len(t[2]) else "")`${2}):
	${0}
endsnippet

snippet defL "private property" !
@property
def _${1}(self):
	${0}
endsnippet

snippet defc "classmethod" !
@classmethod
def ${1}(`!p
snip.rv = 'self'
snip.rv += (", " if len(t[2]) else "")`${2}):
	${0}
endsnippet

snippet defst "staticmethod" !
@staticmethod
def ${1}(${2}):
	${0}
endsnippet

snippet decf "decorated function" !b
@$1
def $2(`!p
if snip.indent:
	snip.rv = 'self'
	snip.rv += (", " if len(t[3]) else "")`$3):
	${0}
endsnippet

snippet inf "logger.info" !b
logger.info(${0})
endsnippet

snippet defs "special function" !
def __${1}__(self`!p
snip.rv = (', ' if len(t[2]) else '')`${2}):
	${0:pass}
endsnippet

snippet init "init function" !b
def __init__(self`!p
snip.rv = (', ' if len(t[1]) else '')`${1}) -> None:
	${0:pass}
endsnippet

snippet ds "docstring" !
''' ${0:doc}
'''
endsnippet

snippet i "import" !b
import $0
endsnippet

##########################
# Try / Except / Finally #
##########################
snippet try "Try / Except" !b
try:
	${VISUAL}
except ${1:Exception}`!p
snip.rv = (' as ' if len(t[2]) else '')`${2:e}:
	${3}
endsnippet

snippet try "Try / Except / Else" b
try:
	${1:pass}
except ${2:Exception}`!p
snip.rv = (' as ' if len(t[3]) else '')`${3:e}:
	${4:raise $3}
else:
	${5:pass}
endsnippet

snippet try "Try / Except / Finally" b
try:
	${1:pass}
except ${2:Exception}`!p
snip.rv = (' as ' if len(t[3]) else '')`${3:e}:
	${4:raise $3}
finally:
	${5:pass}
endsnippet

snippet try "Try / Except / Else / Finally" b
try:
	${1:pass}
except${2: ${3:Exception}`!p
snip.rv = (' as ' if len(t[3]) else '')`${4:e}}:
	${5:raise}
else:
	${6:pass}
finally:
	${7:pass}
endsnippet

snippet "([\([]([^\([.]+)(\.\S+)?\sf)f" "generator for with call on iterator" !r
`!p
snip.rv = '{}or {}'.format(match.group(1), match.group(2))` in ${2:`!p snip.rv = match.group(2)`s}
endsnippet

snippet "\S\sf" "generator for" !r
`!p
snip.rv = '{}or'.format(match.group(0))` ${1:iterator} in ${2:iterable}
endsnippet

snippet sup "super" !i
super().${1:`!p
snip.rv = tek_vim_py_test.current_function_name()`}(${2:`!p
f = tek_vim_py_inspect.containing_function()
if f:
	args = f.args
	a = List.wrap(args.args[1:] + args.kwonlyargs) / _.arg
	s = List(Maybe(args.vararg) / _.arg / '*{}'.format,
					 Maybe(args.kwarg) / _.arg / '**{}'.format).join
	snip.rv = ', '.join(a + s)
`})
endsnippet

snippet aa "private attribute assignment" !b
self._${1:argname} = $1
endsnippet

snippet wv "with statement from visual" !b
with ${VISUAL} as ${2}:
endsnippet

snippet r "return statement" !b
return ${0:value}
endsnippet

global !p
import random
import string

def randname():
    return ''.join(random.sample(string.ascii_lowercase, 6))
endglobal

snippet p "print" !b
print(${1:'${2:text}'})
endsnippet

snippet pr "print repr" !b
print(repr(${0}))
endsnippet

snippet with "context" !b
with ${1:manager}${3: as ${2:identifier}}:
	${0}
endsnippet

snippet from "from import" !b
from $1 import $2
endsnippet

snippet f "from import" !b
from $1 import $2
endsnippet

snippet ti "mypy ignore" !
 # type: ignore
endsnippet

snippet l "self.log" !b
self.log.$1
endsnippet

snippet d "self.log.verbose" !w
self.log.verbose($1)
endsnippet

snippet mes "ribosome message" !b
$1 = message('$1'$2)
endsnippet

snippet mh "may handle" !b
@may_handle($1)
def $2(self):
    $0
endsnippet

snippet nl "ribosome logging import" !b
from ribosome.logging import log
log.verbose($1)
endsnippet

snippet mc "message command" !b
@msg_command($1)
def $2(self):
    pass
endsnippet
